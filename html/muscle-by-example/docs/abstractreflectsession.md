# muscle::AbstractReflectSession class [(API)](https://public.msli.com/lcs/muscle/html/classmuscle_1_1AbstractReflectSession.html)

```#include "reflector/AbstractReflectSession.h"```

* `AbstractReflectSession` is an abstract base class for any object that wants to handle the needs of a single file descriptor in the `ReflectServer`'s event loop.
* Each session object holds an I/O gateway (via an `AbstractMessageIOGatewayRef`) which it uses to convert incoming bytes from its socket/file-descriptor to Messages (and vice versa).  This gateway can be manually installed (via `SetGateway()`), or if not, a default gateway object will be automatically created by calling the session object's `CreateGateway()` method.
* When the session is first attached to the `ReflectServer`, the session's `AttachedToServer()` method will be called.  In this method the session can do any setup/initialization work it wants to do, now that it has access to the `ReflectServer`'s resources.
* Each Message generated by the gateway object's parser (in response to incoming data) is passed to the session via a call to the session's `MessageReceivedFromGateway()` method (which must be implemented by the session subclass)
* When a Message is handed over to the session by one of the other sessions living on the same `ReflectServer`, `MessageReceivedFromSession()` will be called.
* When the session wants to send a Message back to its own client (via the gateway), it can call `AddOutgoingMessage())` to do so.
* When the session's TCP connection is closed (e.g. the client-software associated wih this session has quit or disconnected), the method's `ClientConnectionClosed()` method is called.  The default implementation of this method returns true, indicating that the session object should be detached from the server and destroyed ASAP.
* If the session wants to commit suicide, it can call `EndSession()` on itself and it will be detached and destroyed ASAP.
* Just before the session is detached from the `ReflectServer`, its `AboutToDetachFromServer()` method will be called.  This gives the session a final chance to say its goodbyes, while it still has access to the `ReflectServer`'s resources.
* Included concrete subclasses include `DumbReflectSession` (which simply forwards incoming Messages from the session's gateway to all other connected sessions) and `StorageReflectSession` (which implements the full MUSCLE node-tree-storage and regex-based forwarding logic as described [here](https://public.msli.com/lcs/muscle/muscle/html/Beginners%20Guide.html))

Try compiling and running the mini-example-programs in `muscle/html/muscle-by-example/examples/reflector` (enter `make` to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)

Quick links to source code of relevant MUSCLE-by-example programs:

* [reflector/example_1_dumb_server.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_1_dumb_server.cpp)
* [reflector/example_2_dumb_client.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_2_dumb_client.cpp)
* [reflector/example_3_annotated_dumb_server.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_3_annotated_dumb_server.cpp)
* [reflector/example_4_smart_server.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_4_smart_server.cpp)
* [reflector/example_5_smart_client.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_5_smart_client.cpp)
* [reflector/example_6_smart_server_with_pulsenode.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_6_smart_server_with_pulsenode.cpp)
* [reflector/example_7_smart_server_with_udp_pingpong.cpp](https://public.msli.com/lcs/muscle/muscle/html/muscle-by-example/examples/reflector/example_7_smart_server_with_udp_pingpong.cpp)
